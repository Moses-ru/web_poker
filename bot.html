<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXEL POKER MULTIPLAYER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Конфигурация из окружения
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'poker-multi';

        // Инициализация Telegram
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            // Подстройка цвета под тему Telegram
            document.body.style.backgroundColor = tg.themeParams.bg_color || '#0f0f14';
        }

        // --- ГРАФИЧЕСКАЯ ЧАСТЬ (Canvas) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = 1000, HEIGHT = 750;
        canvas.width = WIDTH; canvas.height = HEIGHT;

        const COLORS = {
            BLACK: '#0a0a0f', WHITE: '#f0f0f5', RED: '#ff1e50',
            GREEN_DARK: '#00641e', GREEN_MID: '#00a032', GOLD: '#ffd700',
            BLUE: '#0082ff', PURPLE: '#7828c8', GRAY: '#50505a'
        };

        const RANKS = '2 3 4 5 6 7 8 9 10 J Q K A'.split(' ');
        const SUITS = ['H', 'D', 'C', 'S'];

        function drawPixelRect(x, y, w, h, p, color, shadow = false) {
            if (shadow) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(x + p + 6, y + 6, w - 2*p, h);
                ctx.fillRect(x + 6, y + p + 6, w, h - 2*p);
            }
            ctx.fillStyle = color;
            ctx.fillRect(x + p, y, w - 2*p, h);
            ctx.fillRect(x, y + p, w, h - 2*p);
        }

        function getSuitGrid(suit) {
            if (suit === 'H') return [[0,1,0,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]];
            if (suit === 'D') return [[0,0,1,0,0], [0,1,1,1,0], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]];
            if (suit === 'S') return [[0,0,1,0,0], [0,1,1,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,0,1,0,0]];
            if (suit === 'C') return [[0,1,1,1,0], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0], [0,1,1,1,0]];
            return [];
        }

        function drawPixelShape(x, y, grid, color, scale = 8) {
            ctx.fillStyle = color;
            grid.forEach((row, ry) => {
                row.forEach((cell, rx) => {
                    if (cell) ctx.fillRect(x + rx * scale, y + ry * scale, scale, scale);
                });
            });
        }

        class Card {
            constructor(rank, suit, x, y, faceUp = false) {
                this.rank = rank; this.suit = suit;
                this.x = x; this.y = y; this.faceUp = faceUp;
            }
            draw(faded = false) {
                const w = 90, h = 128, p = 8;
                drawPixelRect(this.x, this.y, w, h, p, COLORS.BLACK, true);
                if (this.faceUp) {
                    drawPixelRect(this.x, this.y, w, h, p, faded ? COLORS.GRAY : COLORS.WHITE);
                    const color = (this.suit === 'H' || this.suit === 'D') ? COLORS.RED : COLORS.BLACK;
                    ctx.fillStyle = color;
                    ctx.font = '14px "Press Start 2P"';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.rank, this.x + 10, this.y + 25);
                    drawPixelShape(this.x + 25, this.y + 60, getSuitGrid(this.suit), color, 8);
                } else {
                    drawPixelRect(this.x, this.y, w, h, p, COLORS.RED);
                    ctx.strokeStyle = '#a01428'; ctx.lineWidth = 4;
                    ctx.strokeRect(this.x + 15, this.y + 15, w - 30, h - 30);
                }
            }
        }

        // --- ЛОГИКА МУЛЬТИПЛЕЕРА ---
        const Game = {
            user: null,
            roomRef: null,
            roomData: null,
            role: null,
            state: 'CONNECTING',
            roomID: 'lobby_1',
            userId: null,
            userName: null,

            async init() {
                const initAuth = async () => {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                };
                
                await initAuth();

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        this.user = user;
                        // Используем ID пользователя Telegram если доступно
                        this.userId = tg?.initDataUnsafe?.user?.id?.toString() || user.uid;
                        this.userName = tg?.initDataUnsafe?.user?.first_name || "Игрок_" + user.uid.slice(0, 4);
                        this.joinRoom();
                    }
                });

                this.loop();
                window.addEventListener('mousedown', (e) => this.handleClick(e));
                // Поддержка тач-событий для Telegram
                window.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleClick(touch);
                }, { passive: false });
            },

            async joinRoom() {
                if (!this.user) return;
                this.state = 'WAITING';

                this.roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', this.roomID);
                
                try {
                    const snap = await getDoc(this.roomRef);

                    if (!snap.exists() || snap.data().state === 'FINISHED') {
                        this.role = 'host';
                        const initialData = {
                            hostId: this.userId,
                            hostName: this.userName,
                            guestId: null,
                            guestName: null,
                            pot: 0,
                            currentBet: 20,
                            turn: this.userId,
                            state: 'WAITING',
                            community: [],
                            hostCards: this.generateHand(),
                            guestCards: this.generateHand(),
                            lastAction: 'Игра началась'
                        };
                        await setDoc(this.roomRef, initialData);
                    } else {
                        const data = snap.data();
                        if (data.hostId !== this.userId && !data.guestId) {
                            this.role = 'guest';
                            await updateDoc(this.roomRef, { 
                                guestId: this.userId, 
                                guestName: this.userName,
                                state: 'PLAYING'
                            });
                        } else {
                            this.role = (data.hostId === this.userId) ? 'host' : 'guest';
                        }
                    }

                    onSnapshot(this.roomRef, (doc) => {
                        if (!doc.exists()) return;
                        this.roomData = doc.data();
                        this.state = this.roomData.state;
                    }, (err) => console.error("Firestore Error:", err));

                } catch (e) {
                    console.error("Join Room Error:", e);
                }
            },

            generateHand() {
                const getCard = () => ({ 
                    r: RANKS[Math.floor(Math.random()*RANKS.length)], 
                    s: SUITS[Math.floor(Math.random()*SUITS.length)] 
                });
                return [getCard(), getCard()];
            },

            async makeMove(action) {
                if (!this.user || !this.roomData || this.roomData.turn !== this.userId) return;

                let nextTurn = this.role === 'host' ? this.roomData.guestId : this.roomData.hostId;
                let updates = { 
                    turn: nextTurn,
                    lastAction: `${this.userName}: ${action}`
                };

                if (action === 'CALL') {
                    updates.pot = this.roomData.pot + this.roomData.currentBet;
                    if (this.roomData.community.length === 0) {
                        updates.community = [this.generateHand()[0], this.generateHand()[0], this.generateHand()[0]];
                    } else if (this.roomData.community.length < 5) {
                        updates.community = [...this.roomData.community, this.generateHand()[0]];
                    } else {
                        updates.state = 'SHOWDOWN';
                    }
                } else if (action === 'FOLD') {
                    updates.state = 'FINISHED';
                    updates.lastAction = `${this.userName} сдался`;
                }

                await updateDoc(this.roomRef, updates);
            },

            handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = WIDTH / rect.width;
                const scaleY = HEIGHT / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                if (this.state === 'PLAYING' && this.roomData?.turn === this.userId) {
                    if (x > 390 && x < 510 && y > 660 && y < 720) this.makeMove('CALL');
                    if (x > 260 && x < 380 && y > 660 && y < 720) this.makeMove('FOLD');
                }
                
                if (this.state === 'SHOWDOWN' || this.state === 'FINISHED') {
                   updateDoc(this.roomRef, { state: 'FINISHED' }).then(() => location.reload());
                }
            },

            drawPanel(text, x, y, textCol, bgCol, borderCol, width = 250) {
                ctx.font = '10px "Press Start 2P"';
                const h = 40;
                drawPixelRect(x - width/2, y - h/2, width, h, 6, COLORS.BLACK, true);
                drawPixelRect(x - width/2, y - h/2, width, h, 6, borderCol);
                drawPixelRect(x - width/2 + 4, y - h/2 + 4, width - 8, h - 8, 4, bgCol);
                ctx.fillStyle = textCol;
                ctx.textAlign = 'center';
                ctx.fillText(text, x, y + 5);
            },

            loop() {
                ctx.fillStyle = '#0f0f14';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                if (this.state === 'CONNECTING') {
                    this.drawPanel("ПОДКЛЮЧЕНИЕ...", WIDTH/2, HEIGHT/2, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD);
                } else if (this.state === 'WAITING' || !this.roomData) {
                    this.drawPanel("ОЖИДАНИЕ ИГРОКА...", WIDTH/2, HEIGHT/2, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD, 400);
                    ctx.font = '8px "Press Start 2P"';
                    ctx.fillText(`ROOM: ${this.roomID}`, WIDTH/2, HEIGHT/2 + 50);
                    ctx.fillText(`ID: ${this.userId}`, WIDTH/2, HEIGHT/2 + 70);
                } else {
                    drawPixelRect(30, 20, 940, 620, 32, COLORS.GREEN_DARK);
                    drawPixelRect(50, 40, 900, 580, 24, COLORS.GREEN_MID);

                    const myCardsData = this.role === 'host' ? this.roomData.hostCards : this.roomData.guestCards;
                    myCardsData.forEach((c, i) => new Card(c.r, c.s, 410 + i*110, 500, true).draw());

                    const oppCardsData = this.role === 'host' ? this.roomData.guestCards : this.roomData.hostCards;
                    oppCardsData.forEach((c, i) => new Card(c.r, c.s, 410 + i*110, 80, this.state === 'SHOWDOWN').draw());

                    this.roomData.community.forEach((c, i) => new Card(c.r, c.s, 180 + i*110, 290, true).draw());

                    const myName = this.userName;
                    const oppName = this.role === 'host' ? (this.roomData.guestName || "Ожидание...") : this.roomData.hostName;
                    
                    this.drawPanel(`${myName} (ВЫ)`, 150, 690, COLORS.WHITE, COLORS.BLUE, COLORS.BLACK);
                    this.drawPanel(oppName, 150, 60, COLORS.WHITE, COLORS.RED, COLORS.BLACK);
                    this.drawPanel(`БАНК: $${this.roomData.pot}`, 865, 270, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE);
                    
                    const isMyTurn = this.roomData.turn === this.userId;
                    const statusMsg = isMyTurn ? "ВАШ ХОД" : "ХОД ПРОТИВНИКА";
                    this.drawPanel(statusMsg, WIDTH/2, 210, COLORS.WHITE, COLORS.PURPLE, COLORS.WHITE, 350);

                    if (this.state === 'PLAYING' && isMyTurn) {
                        drawPixelRect(260, 660, 120, 60, 8, COLORS.WHITE);
                        ctx.fillStyle = COLORS.BLACK; ctx.fillText("FOLD", 320, 695);
                        drawPixelRect(390, 660, 120, 60, 8, COLORS.WHITE);
                        ctx.fillStyle = COLORS.BLACK; ctx.fillText("CALL", 450, 695);
                    }
                    
                    if (this.state === 'SHOWDOWN' || this.state === 'FINISHED') {
                        const winMsg = this.state === 'FINISHED' ? "ИГРА ОКОНЧЕНА" : "ФИНАЛ! ТАП ДЛЯ ПЕРЕЗАГРУЗКИ";
                        this.drawPanel(winMsg, WIDTH/2, 400, COLORS.BLACK, COLORS.GOLD, COLORS.BLACK, 600);
                    }
                }

                requestAnimationFrame(() => this.loop());
            }
        };

        // Запуск только после полной загрузки страницы
        window.onload = () => Game.init();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { 
            background-color: #0f0f14; 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            color: #f0f0f5; 
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Предотвращает зум и скролл в Telegram */
        }
        #game-container { 
            position: relative; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8); 
            border: 4px solid #50505a;
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 1000 / 750;
        }
        canvas { 
            image-rendering: pixelated; 
            display: block; 
            width: 100%;
            height: 100%;
        }
        #crt-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03)); background-size: 100% 3px, 3px 100%; z-index: 10; }
        #crt-overlay::after { content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0; background: radial-gradient(circle, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.4) 100%); }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="crt-overlay"></div>
    </div>
</body>
</html>