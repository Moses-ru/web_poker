<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXEL POKER MULTIPLAYER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBq82rTga0Aeh1TueIbGJ7hyRq-rrF_m7Y",
            authDomain: "bot-moses.firebaseapp.com",
            projectId: "bot-moses",
            storageBucket: "bot-moses.firebasestorage.app",
            messagingSenderId: "351893627982",
            appId: "1:351893627982:web:bcd3a0c51d78ee70358f1f",
            measurementId: "G-D9P14CDNB6"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = "bot-moses-game"; 

        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = 1000, HEIGHT = 750;
        canvas.width = WIDTH; canvas.height = HEIGHT;

        const COLORS = {
            BLACK: '#0a0a0f', WHITE: '#f0f0f5', RED: '#ff1e50',
            GREEN_DARK: '#004d1a', GREEN_MID: '#00802b', GOLD: '#ffd700',
            BLUE: '#0082ff', PURPLE: '#7828c8', GRAY: '#50505a', DARK_GRAY: '#202025'
        };

        const RANKS = '2 3 4 5 6 7 8 9 10 J Q K A'.split(' ');
        const SUITS = ['H', 'D', 'C', 'S'];

        function drawPixelRect(x, y, w, h, p, color, shadow = false) {
            if (shadow) {
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(x + p + 4, y + 4, w - 2*p, h);
                ctx.fillRect(x + 4, y + p + 4, w, h - 2*p);
            }
            ctx.fillStyle = color;
            ctx.fillRect(x + p, y, w - 2*p, h);
            ctx.fillRect(x, y + p, w, h - 2*p);
        }

        function getSuitGrid(suit) {
            if (suit === 'H') return [[0,1,0,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]];
            if (suit === 'D') return [[0,0,1,0,0], [0,1,1,1,0], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]];
            if (suit === 'S') return [[0,0,1,0,0], [0,1,1,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,0,1,0,0]];
            if (suit === 'C') return [[0,1,1,1,0], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0], [0,1,1,1,0]];
            return [];
        }

        function drawPixelShape(x, y, grid, color, scale = 8) {
            ctx.fillStyle = color;
            grid.forEach((row, ry) => {
                row.forEach((cell, rx) => {
                    if (cell) ctx.fillRect(x + rx * scale, y + ry * scale, scale, scale);
                });
            });
        }

        class Card {
            constructor(rank, suit, x, y, faceUp = false) {
                this.rank = rank; this.suit = suit;
                this.x = x; this.y = y; this.faceUp = faceUp;
            }
            draw(faded = false) {
                const w = 90, h = 128, p = 8;
                drawPixelRect(this.x, this.y, w, h, p, COLORS.BLACK, true);
                if (this.faceUp) {
                    drawPixelRect(this.x, this.y, w, h, p, faded ? COLORS.GRAY : COLORS.WHITE);
                    const color = (this.suit === 'H' || this.suit === 'D') ? COLORS.RED : COLORS.BLACK;
                    ctx.fillStyle = color;
                    ctx.font = '14px "Press Start 2P"';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.rank, this.x + 10, this.y + 25);
                    drawPixelShape(this.x + 25, this.y + 60, getSuitGrid(this.suit), color, 8);
                } else {
                    drawPixelRect(this.x, this.y, w, h, p, COLORS.RED);
                    ctx.strokeStyle = '#a01428'; ctx.lineWidth = 4;
                    ctx.strokeRect(this.x + 15, this.y + 15, w - 30, h - 30);
                }
            }
        }

        window.Game = {
            user: null, roomRef: null, roomData: null, role: null,
            state: 'LOBBY', rooms: [], userId: null, userName: null,
            errorMessage: null, userBalance: 1000,

            async init() {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        this.user = user;
                        this.userId = tg?.initDataUnsafe?.user?.id?.toString() || user.uid;
                        this.userName = tg?.initDataUnsafe?.user?.first_name || "Игрок_" + this.userId.slice(0, 4);
                        await this.refreshLobby();
                    } else {
                        signInAnonymously(auth);
                    }
                });

                this.loop();
                window.addEventListener('mousedown', (e) => this.handleClick(e));
                window.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleClick(e.touches[0]);
                }, { passive: false });
            },

            async refreshLobby() {
                try {
                    const roomsCol = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');
                    const snap = await getDocs(roomsCol);
                    this.rooms = snap.docs
                        .map(doc => ({ id: doc.id, ...doc.data() }))
                        .filter(r => r.state === 'WAITING' || r.state === 'PLAYING');
                    this.errorMessage = null;
                } catch(e) { 
                    this.errorMessage = "Ошибка Firestore: Проверьте правила";
                }
            },

            async createRoom() {
                this.state = 'CONNECTING';
                try {
                    const roomID = `room_${this.userId}`;
                    this.roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomID);
                    this.role = 'host';
                    const initialData = {
                        hostId: this.userId, hostName: this.userName, hostBalance: this.userBalance,
                        guestId: null, guestName: null, guestBalance: 0,
                        pot: 0, currentBet: 0, lastBet: 20, turn: this.userId,
                        state: 'WAITING', community: [],
                        hostCards: this.generateHand(), guestCards: this.generateHand(),
                        lastAction: 'Ожидание оппонента', winner: null
                    };
                    await setDoc(this.roomRef, initialData);
                    this.listenToRoom();
                } catch(e) {
                    this.state = 'LOBBY';
                    this.errorMessage = "Ошибка создания: " + e.message;
                }
            },

            async joinRoom(roomID) {
                this.state = 'CONNECTING';
                try {
                    this.roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomID);
                    this.role = 'guest';
                    await updateDoc(this.roomRef, { 
                        guestId: this.userId, guestName: this.userName, guestBalance: this.userBalance, state: 'PLAYING'
                    });
                    this.listenToRoom();
                } catch(e) {
                    this.state = 'LOBBY';
                    this.errorMessage = "Ошибка входа: " + e.message;
                }
            },

            async leaveRoom() {
                if (this.roomRef) {
                    if (this.role === 'host') {
                        await deleteDoc(this.roomRef);
                    } else {
                        await updateDoc(this.roomRef, { guestId: null, guestName: null, state: 'WAITING' });
                    }
                }
                this.state = 'LOBBY';
                this.roomRef = null;
                this.roomData = null;
                this.refreshLobby();
            },

            listenToRoom() {
                onSnapshot(this.roomRef, (doc) => {
                    if (doc.exists()) {
                        this.roomData = doc.data();
                        this.state = this.roomData.state;
                        if (this.role === 'host') this.userBalance = this.roomData.hostBalance;
                        else this.userBalance = this.roomData.guestBalance;
                    } else {
                        this.state = 'LOBBY';
                    }
                }, (err) => {
                    this.errorMessage = "Ошибка синхронизации: " + err.message;
                });
            },

            generateHand() {
                const getCard = () => ({ 
                    r: RANKS[Math.floor(Math.random()*RANKS.length)], 
                    s: SUITS[Math.floor(Math.random()*SUITS.length)] 
                });
                return [getCard(), getCard()];
            },

            async makeMove(action) {
                if (!this.roomData || this.roomData.turn !== this.userId) return;
                let nextTurn = this.role === 'host' ? this.roomData.guestId : this.roomData.hostId;
                let updates = { turn: nextTurn, lastAction: `${this.userName}: ${action}` };

                const betAmount = this.roomData.lastBet;

                if (action === 'CALL') {
                    updates.pot = this.roomData.pot + betAmount;
                    if (this.role === 'host') updates.hostBalance = this.roomData.hostBalance - betAmount;
                    else updates.guestBalance = this.roomData.guestBalance - betAmount;

                    // Продвижение по стадиям
                    if (this.roomData.community.length === 0) updates.community = [this.generateHand()[0], this.generateHand()[0], this.generateHand()[0]];
                    else if (this.roomData.community.length < 5) updates.community = [...this.roomData.community, this.generateHand()[0]];
                    else {
                        updates.state = 'SHOWDOWN';
                        updates.winner = this.calculateWinner();
                    }
                } else if (action === 'RAISE') {
                    const raiseVal = betAmount + 20;
                    updates.pot = this.roomData.pot + raiseVal;
                    updates.lastBet = raiseVal;
                    if (this.role === 'host') updates.hostBalance = this.roomData.hostBalance - raiseVal;
                    else updates.guestBalance = this.roomData.guestBalance - raiseVal;
                } else if (action === 'FOLD') {
                    updates.state = 'FINISHED';
                    updates.winner = this.role === 'host' ? 'guest' : 'host';
                }

                await updateDoc(this.roomRef, updates);
            },

            calculateWinner() {
                // Упрощенная логика: кто больше по сумме рангов
                const getPower = (cards) => cards.reduce((sum, c) => sum + RANKS.indexOf(c.r), 0);
                const hostPower = getPower([...this.roomData.hostCards, ...this.roomData.community]);
                const guestPower = getPower([...this.roomData.guestCards, ...this.roomData.community]);
                return hostPower >= guestPower ? 'host' : 'guest';
            },

            handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (WIDTH / rect.width);
                const y = (e.clientY - rect.top) * (HEIGHT / rect.height);

                if (this.state === 'LOBBY') {
                    if (x > 700 && x < 950 && y > 650 && y < 710) this.createRoom();
                    if (x > 50 && x < 250 && y > 650 && y < 710) this.refreshLobby();
                    this.rooms.forEach((room, i) => {
                        const ry = 180 + i * 80;
                        if (x > 100 && x < 900 && y > ry && y < ry + 60) this.joinRoom(room.id);
                    });
                } else if (this.state === 'WAITING' || this.state === 'PLAYING') {
                    // Кнопка ВЫЙТИ (сверху справа)
                    if (x > 850 && x < 980 && y > 20 && y < 70) this.leaveRoom();
                    
                    if (this.state === 'PLAYING' && this.roomData?.turn === this.userId) {
                        if (x > 410 && x < 530 && y > 660 && y < 720) this.makeMove('CALL');
                        if (x > 540 && x < 660 && y > 660 && y < 720) this.makeMove('RAISE');
                        if (x > 280 && x < 400 && y > 660 && y < 720) this.makeMove('FOLD');
                    }
                } else if (this.state === 'SHOWDOWN' || this.state === 'FINISHED') {
                    this.leaveRoom();
                }
            },

            drawPanel(text, x, y, textCol, bgCol, borderCol, width = 250, height = 40) {
                ctx.font = '10px "Press Start 2P"';
                drawPixelRect(x - width/2, y - height/2, width, height, 6, COLORS.BLACK, true);
                drawPixelRect(x - width/2, y - height/2, width, height, 6, borderCol);
                drawPixelRect(x - width/2 + 4, y - height/2 + 4, width - 8, height - 8, 4, bgCol);
                ctx.fillStyle = textCol;
                ctx.textAlign = 'center';
                ctx.fillText(text, x, y + 5);
            },

            drawChips(x, y, count) {
                const stack = Math.min(Math.floor(count / 20), 10);
                for(let i=0; i<stack; i++) {
                    ctx.fillStyle = COLORS.BLACK;
                    ctx.beginPath(); ctx.ellipse(x, y - i*4, 15, 8, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = i % 2 === 0 ? COLORS.RED : COLORS.BLUE;
                    ctx.beginPath(); ctx.ellipse(x, y - i*4 - 2, 15, 8, 0, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = COLORS.WHITE; ctx.lineWidth = 1;
                    ctx.stroke();
                }
            },

            loop() {
                ctx.fillStyle = COLORS.DARK_GRAY;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                if (this.errorMessage) {
                    this.drawPanel(this.errorMessage, WIDTH/2, 25, COLORS.WHITE, COLORS.RED, COLORS.WHITE, 900, 30);
                }

                if (this.state === 'LOBBY') {
                    this.drawPanel("ЛОББИ PIXEL POKER", WIDTH/2, 80, COLORS.GOLD, COLORS.BLACK, COLORS.GOLD, 600, 60);
                    this.drawPanel(`БАЛАНС: $${this.userBalance}`, WIDTH/2, 140, COLORS.WHITE, COLORS.DARK_GRAY, COLORS.GRAY, 300, 30);
                    
                    if (this.rooms.length === 0) {
                        ctx.fillStyle = COLORS.GRAY; ctx.textAlign = 'center';
                        ctx.fillText("НЕТ ДОСТУПНЫХ КОМНАТ", WIDTH/2, HEIGHT/2);
                    }
                    this.rooms.forEach((room, i) => {
                        const ry = 220 + i * 80;
                        const status = room.state === 'WAITING' ? 'СВОБОДНО' : 'В ИГРЕ';
                        this.drawPanel(`${room.hostName.toUpperCase()} - ${status}`, WIDTH/2, ry, COLORS.WHITE, room.state === 'WAITING' ? COLORS.BLUE : COLORS.PURPLE, COLORS.WHITE, 800, 60);
                    });

                    this.drawPanel("ОБНОВИТЬ", 150, 680, COLORS.WHITE, COLORS.GRAY, COLORS.WHITE, 220, 60);
                    this.drawPanel("СОЗДАТЬ", 825, 680, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE, 250, 60);

                } else if (this.state === 'CONNECTING') {
                    this.drawPanel("ПОДКЛЮЧЕНИЕ К СЕТИ...", WIDTH/2, HEIGHT/2, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD, 500);
                } else {
                    // ИГРОВОЙ СТОЛ
                    drawPixelRect(30, 20, 940, 620, 32, COLORS.GREEN_DARK);
                    drawPixelRect(50, 40, 900, 580, 24, COLORS.GREEN_MID);

                    // Кнопка Выйти
                    this.drawPanel("ВЫЙТИ", 915, 45, COLORS.WHITE, COLORS.RED, COLORS.WHITE, 120, 40);

                    if (this.roomData) {
                        const isHost = this.role === 'host';
                        const myCards = isHost ? this.roomData.hostCards : this.roomData.guestCards;
                        const oppCards = isHost ? this.roomData.guestCards : this.roomData.hostCards;
                        const myBalance = isHost ? this.roomData.hostBalance : this.roomData.guestBalance;
                        const oppBalance = isHost ? this.roomData.guestBalance : this.roomData.hostBalance;

                        // Карты
                        myCards.forEach((c, i) => new Card(c.r, c.s, 410 + i*110, 500, true).draw());
                        oppCards.forEach((c, i) => new Card(c.r, c.s, 410 + i*110, 80, this.state === 'SHOWDOWN').draw());
                        this.roomData.community.forEach((c, i) => new Card(c.r, c.s, 230 + i*105, 290, true).draw());

                        // Фишки и Баланс
                        this.drawChips(350, 550, myBalance);
                        this.drawChips(350, 150, oppBalance);
                        this.drawPanel(`$${myBalance}`, 350, 600, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD, 120);
                        this.drawPanel(`$${oppBalance}`, 350, 80, COLORS.WHITE, COLORS.BLACK, COLORS.GRAY, 120);

                        // Инфо
                        this.drawPanel(`${this.userName}`, 150, 690, COLORS.WHITE, COLORS.BLUE, COLORS.WHITE);
                        this.drawPanel(`БАНК: $${this.roomData.pot}`, WIDTH/2, 450, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE, 300);
                        
                        const isMyTurn = this.roomData.turn === this.userId;
                        if (this.state === 'WAITING') {
                            this.drawPanel("ОЖИДАНИЕ ИГРОКА...", WIDTH/2, 230, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD, 400);
                        } else if (this.state === 'PLAYING') {
                            this.drawPanel(isMyTurn ? "ВАШ ХОД" : "ХОД ОППОНЕНТА", WIDTH/2, 210, COLORS.WHITE, isMyTurn ? COLORS.PURPLE : COLORS.GRAY, COLORS.WHITE, 350);
                            if (isMyTurn) {
                                this.drawPanel("FOLD", 340, 690, COLORS.BLACK, COLORS.WHITE, COLORS.RED, 120, 60);
                                this.drawPanel(`CALL $${this.roomData.lastBet}`, 470, 690, COLORS.BLACK, COLORS.WHITE, COLORS.BLUE, 120, 60);
                                this.drawPanel("RAISE", 600, 690, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE, 120, 60);
                            }
                        } else {
                            const winText = this.roomData.winner === this.role ? "ВЫ ВЫИГРАЛИ!" : "ВЫ ПРОИГРАЛИ!";
                            this.drawPanel(winText, WIDTH/2, 400, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE, 600, 80);
                            ctx.font = '8px "Press Start 2P"';
                            ctx.fillStyle = COLORS.WHITE;
                            ctx.fillText("НАЖМИТЕ ДЛЯ ВЫХОДА В ЛОББИ", WIDTH/2, 460);
                        }
                    }
                }
                requestAnimationFrame(() => this.loop());
            }
        };

        window.onload = () => window.Game.init();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { background-color: #0f0f14; margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; color: #f0f0f5; font-family: 'Press Start 2P', cursive; touch-action: none; }
        #game-container { position: relative; border: 4px solid #50505a; width: 100%; max-width: 1000px; aspect-ratio: 1000 / 750; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        canvas { image-rendering: pixelated; display: block; width: 100%; height: 100%; }
        #crt-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03)); background-size: 100% 3px, 3px 100%; z-index: 10; opacity: 0.4; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="crt-overlay"></div>
    </div>
</body>
</html>
