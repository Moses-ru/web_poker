<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXEL POKER MULTIPLAYER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Firebase SDKs - ИСПОЛЬЗУЕМ ПОЛНЫЕ URL ДЛЯ БРАУЗЕРА -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, collection, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Ваша конфигурация
        const firebaseConfig = {
            apiKey: "AIzaSyBq82rTga0Aeh1TueIbGJ7hyRq-rrF_m7Y",
            authDomain: "bot-moses.firebaseapp.com",
            projectId: "bot-moses",
            storageBucket: "bot-moses.firebasestorage.app",
            messagingSenderId: "351893627982",
            appId: "1:351893627982:web:bcd3a0c51d78ee70358f1f",
            measurementId: "G-D9P14CDNB6"
        };

        // Инициализация Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Используем projectId как appId для путей Firestore, если запускаем вне моей среды
        const appId = "bot-moses-game"; 

        // Инициализация Telegram
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            document.body.style.backgroundColor = tg.themeParams.bg_color || '#0f0f14';
        }

        // --- ГРАФИЧЕСКАЯ ЧАСТЬ (Canvas) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = 1000, HEIGHT = 750;
        canvas.width = WIDTH; canvas.height = HEIGHT;

        const COLORS = {
            BLACK: '#0a0a0f', WHITE: '#f0f0f5', RED: '#ff1e50',
            GREEN_DARK: '#00641e', GREEN_MID: '#00a032', GOLD: '#ffd700',
            BLUE: '#0082ff', PURPLE: '#7828c8', GRAY: '#50505a'
        };

        const RANKS = '2 3 4 5 6 7 8 9 10 J Q K A'.split(' ');
        const SUITS = ['H', 'D', 'C', 'S'];

        function drawPixelRect(x, y, w, h, p, color, shadow = false) {
            if (shadow) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(x + p + 6, y + 6, w - 2*p, h);
                ctx.fillRect(x + 6, y + p + 6, w, h - 2*p);
            }
            ctx.fillStyle = color;
            ctx.fillRect(x + p, y, w - 2*p, h);
            ctx.fillRect(x, y + p, w, h - 2*p);
        }

        function getSuitGrid(suit) {
            if (suit === 'H') return [[0,1,0,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]];
            if (suit === 'D') return [[0,0,1,0,0], [0,1,1,1,0], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0]];
            if (suit === 'S') return [[0,0,1,0,0], [0,1,1,1,0], [1,1,1,1,1], [1,1,1,1,1], [0,0,1,0,0]];
            if (suit === 'C') return [[0,1,1,1,0], [1,1,1,1,1], [0,1,1,1,0], [0,0,1,0,0], [0,1,1,1,0]];
            return [];
        }

        function drawPixelShape(x, y, grid, color, scale = 8) {
            ctx.fillStyle = color;
            grid.forEach((row, ry) => {
                row.forEach((cell, rx) => {
                    if (cell) ctx.fillRect(x + rx * scale, y + ry * scale, scale, scale);
                });
            });
        }

        class Card {
            constructor(rank, suit, x, y, faceUp = false) {
                this.rank = rank; this.suit = suit;
                this.x = x; this.y = y; this.faceUp = faceUp;
            }
            draw(faded = false) {
                const w = 90, h = 128, p = 8;
                drawPixelRect(this.x, this.y, w, h, p, COLORS.BLACK, true);
                if (this.faceUp) {
                    drawPixelRect(this.x, this.y, w, h, p, faded ? COLORS.GRAY : COLORS.WHITE);
                    const color = (this.suit === 'H' || this.suit === 'D') ? COLORS.RED : COLORS.BLACK;
                    ctx.fillStyle = color;
                    ctx.font = '14px "Press Start 2P"';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.rank, this.x + 10, this.y + 25);
                    drawPixelShape(this.x + 25, this.y + 60, getSuitGrid(this.suit), color, 8);
                } else {
                    drawPixelRect(this.x, this.y, w, h, p, COLORS.RED);
                    ctx.strokeStyle = '#a01428'; ctx.lineWidth = 4;
                    ctx.strokeRect(this.x + 15, this.y + 15, w - 30, h - 30);
                }
            }
        }

        // --- ЛОГИКА МУЛЬТИПЛЕЕРА ---
        window.Game = {
            user: null,
            roomRef: null,
            roomData: null,
            role: null,
            state: 'LOBBY',
            rooms: [],
            userId: null,
            userName: null,

            async init() {
                // Анонимный вход
                try {
                    await signInAnonymously(auth);
                } catch (e) {
                    console.error("Auth failed:", e);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        this.user = user;
                        this.userId = tg?.initDataUnsafe?.user?.id?.toString() || user.uid;
                        this.userName = tg?.initDataUnsafe?.user?.first_name || "Player_" + user.uid.slice(0, 4);
                        this.refreshLobby();
                    }
                });

                this.loop();
                window.addEventListener('mousedown', (e) => this.handleClick(e));
                window.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleClick(e.touches[0]);
                }, { passive: false });
            },

            async refreshLobby() {
                try {
                    const roomsCol = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');
                    const snap = await getDocs(roomsCol);
                    this.rooms = snap.docs
                        .map(doc => ({ id: doc.id, ...doc.data() }))
                        .filter(r => r.state === 'WAITING');
                } catch(e) { console.error("Refresh fail:", e); }
            },

            async createRoom() {
                this.state = 'CONNECTING';
                const roomID = `room_${Date.now()}`;
                this.roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomID);
                this.role = 'host';
                const initialData = {
                    hostId: this.userId, hostName: this.userName,
                    guestId: null, guestName: null,
                    pot: 0, currentBet: 20, turn: this.userId,
                    state: 'WAITING', community: [],
                    hostCards: this.generateHand(), guestCards: this.generateHand(),
                    lastAction: 'Waiting for player'
                };
                await setDoc(this.roomRef, initialData);
                this.listenToRoom();
            },

            async joinRoom(roomID) {
                this.state = 'CONNECTING';
                this.roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomID);
                this.role = 'guest';
                await updateDoc(this.roomRef, { 
                    guestId: this.userId, guestName: this.userName, state: 'PLAYING'
                });
                this.listenToRoom();
            },

            listenToRoom() {
                onSnapshot(this.roomRef, (doc) => {
                    if (doc.exists()) {
                        this.roomData = doc.data();
                        this.state = this.roomData.state;
                    }
                });
            },

            generateHand() {
                const getCard = () => ({ 
                    r: RANKS[Math.floor(Math.random()*RANKS.length)], 
                    s: SUITS[Math.floor(Math.random()*SUITS.length)] 
                });
                return [getCard(), getCard()];
            },

            async makeMove(action) {
                if (!this.roomData || this.roomData.turn !== this.userId) return;
                let nextTurn = this.role === 'host' ? this.roomData.guestId : this.roomData.hostId;
                let updates = { turn: nextTurn, lastAction: `${this.userName}: ${action}` };

                if (action === 'CALL') {
                    updates.pot = this.roomData.pot + this.roomData.currentBet;
                    if (this.roomData.community.length === 0) updates.community = [this.generateHand()[0], this.generateHand()[0], this.generateHand()[0]];
                    else if (this.roomData.community.length < 5) updates.community = [...this.roomData.community, this.generateHand()[0]];
                    else updates.state = 'SHOWDOWN';
                } else if (action === 'FOLD') {
                    updates.state = 'FINISHED';
                }
                await updateDoc(this.roomRef, updates);
            },

            handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (WIDTH / rect.width);
                const y = (e.clientY - rect.top) * (HEIGHT / rect.height);

                if (this.state === 'LOBBY') {
                    if (x > 700 && x < 950 && y > 650 && y < 710) this.createRoom();
                    if (x > 50 && x < 250 && y > 650 && y < 710) this.refreshLobby();
                    this.rooms.forEach((room, i) => {
                        const ry = 150 + i * 80;
                        if (x > 100 && x < 900 && y > ry && y < ry + 60) this.joinRoom(room.id);
                    });
                }
                if (this.state === 'PLAYING' && this.roomData?.turn === this.userId) {
                    if (x > 390 && x < 510 && y > 660 && y < 720) this.makeMove('CALL');
                    if (x > 260 && x < 380 && y > 660 && y < 720) this.makeMove('FOLD');
                }
                if (this.state === 'SHOWDOWN' || this.state === 'FINISHED') location.reload();
            },

            drawPanel(text, x, y, textCol, bgCol, borderCol, width = 250, height = 40) {
                ctx.font = '10px "Press Start 2P"';
                drawPixelRect(x - width/2, y - height/2, width, height, 6, COLORS.BLACK, true);
                drawPixelRect(x - width/2, y - height/2, width, height, 6, borderCol);
                drawPixelRect(x - width/2 + 4, y - height/2 + 4, width - 8, height - 8, 4, bgCol);
                ctx.fillStyle = textCol;
                ctx.textAlign = 'center';
                ctx.fillText(text, x, y + 5);
            },

            loop() {
                ctx.fillStyle = '#0f0f14';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                if (this.state === 'LOBBY') {
                    this.drawPanel("LOBBY - PIXEL POKER", WIDTH/2, 60, COLORS.GOLD, COLORS.BLACK, COLORS.GOLD, 500, 60);
                    if (this.rooms.length === 0) {
                        ctx.fillStyle = COLORS.GRAY; ctx.textAlign = 'center';
                        ctx.fillText("NO ROOMS FOUND", WIDTH/2, HEIGHT/2);
                    }
                    this.rooms.forEach((room, i) => {
                        const ry = 150 + i * 80;
                        this.drawPanel(`JOIN: ${room.hostName.toUpperCase()}`, WIDTH/2, ry + 30, COLORS.WHITE, COLORS.BLUE, COLORS.WHITE, 800, 60);
                    });
                    this.drawPanel("CREATE GAME", 825, 680, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE, 250, 60);
                    this.drawPanel("REFRESH", 150, 680, COLORS.WHITE, COLORS.GRAY, COLORS.WHITE, 200, 60);
                } else if (this.state === 'CONNECTING') {
                    this.drawPanel("CONNECTING...", WIDTH/2, HEIGHT/2, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD);
                } else if (this.state === 'WAITING' || !this.roomData) {
                    this.drawPanel("WAITING FOR OPPONENT...", WIDTH/2, HEIGHT/2, COLORS.WHITE, COLORS.BLACK, COLORS.GOLD, 450);
                } else {
                    drawPixelRect(30, 20, 940, 620, 32, COLORS.GREEN_DARK);
                    drawPixelRect(50, 40, 900, 580, 24, COLORS.GREEN_MID);
                    const myCards = this.role === 'host' ? this.roomData.hostCards : this.roomData.guestCards;
                    myCards.forEach((c, i) => new Card(c.r, c.s, 410 + i*110, 500, true).draw());
                    const oppCards = this.role === 'host' ? this.roomData.guestCards : this.roomData.hostCards;
                    oppCards.forEach((c, i) => new Card(c.r, c.s, 410 + i*110, 80, this.state === 'SHOWDOWN').draw());
                    this.roomData.community.forEach((c, i) => new Card(c.r, c.s, 180 + i*110, 290, true).draw());
                    this.drawPanel(`${this.userName} (YOU)`, 150, 690, COLORS.WHITE, COLORS.BLUE, COLORS.BLACK);
                    this.drawPanel(this.role === 'host' ? (this.roomData.guestName || "Waiting...") : this.roomData.hostName, 150, 60, COLORS.WHITE, COLORS.RED, COLORS.BLACK);
                    this.drawPanel(`POT: $${this.roomData.pot}`, 865, 270, COLORS.BLACK, COLORS.GOLD, COLORS.WHITE);
                    const isMyTurn = this.roomData.turn === this.userId;
                    this.drawPanel(isMyTurn ? "YOUR TURN" : "OPPONENT'S TURN", WIDTH/2, 210, COLORS.WHITE, COLORS.PURPLE, COLORS.WHITE, 350);
                    if (this.state === 'PLAYING' && isMyTurn) {
                        drawPixelRect(260, 660, 120, 60, 8, COLORS.WHITE);
                        ctx.fillStyle = COLORS.BLACK; ctx.fillText("FOLD", 320, 695);
                        drawPixelRect(390, 660, 120, 60, 8, COLORS.WHITE);
                        ctx.fillStyle = COLORS.BLACK; ctx.fillText("CALL", 450, 695);
                    }
                    if (this.state === 'SHOWDOWN' || this.state === 'FINISHED') {
                        this.drawPanel("GAME OVER! TAP TO LOBBY", WIDTH/2, 400, COLORS.BLACK, COLORS.GOLD, COLORS.BLACK, 600);
                    }
                }
                requestAnimationFrame(() => this.loop());
            }
        };

        window.onload = () => window.Game.init();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { background-color: #0f0f14; margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; color: #f0f0f5; font-family: 'Press Start 2P', cursive; touch-action: none; }
        #game-container { position: relative; border: 4px solid #50505a; width: 100%; max-width: 1000px; aspect-ratio: 1000 / 750; }
        canvas { image-rendering: pixelated; display: block; width: 100%; height: 100%; }
        #crt-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03)); background-size: 100% 3px, 3px 100%; z-index: 10; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="crt-overlay"></div>
    </div>
</body>
</html>
